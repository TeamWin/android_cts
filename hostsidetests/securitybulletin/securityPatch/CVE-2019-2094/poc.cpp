/**
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "../includes/common.h"

#include <binder/ProcessState.h>
#include <media/DataSource.h>
#include <media/IMediaHTTPService.h>
#include <media/IStreamSource.h>
#include <media/mediaplayer.h>
#include <media/MediaSource.h>
#include <media/stagefright/foundation/ADebug.h>
#include <media/stagefright/foundation/AMessage.h>
#include <media/stagefright/DataSourceFactory.h>
#include <media/stagefright/InterfaceUtils.h>
#include <media/stagefright/MPEG2TSWriter.h>
#include <media/MediaExtractor.h>
#include <media/stagefright/MediaExtractorFactory.h>
#include <media/stagefright/MetaData.h>
#include <binder/IServiceManager.h>
#include <media/IMediaPlayerService.h>
#include <gui/ISurfaceComposer.h>
#include <gui/SurfaceComposerClient.h>
#include <gui/Surface.h>
#include <fcntl.h>
#include <ui/DisplayInfo.h>

using namespace android;

struct MyStreamSource : public BnStreamSource {
public:
    explicit MyStreamSource(int fd);

    virtual void setListener(const sp<IStreamListener> &listener);
    virtual void setBuffers(const Vector<sp<IMemory> > &buffers);
    virtual void onBufferAvailable(size_t index);

 protected:
    virtual ~MyStreamSource();

 private:
    int mFd;
    off64_t mFileSize;
    uint64_t mNumPacketsSent;
    sp<IStreamListener> mListener;
    Vector<sp<IMemory>> mBuffers;

    DISALLOW_EVIL_CONSTRUCTORS (MyStreamSource);
};

MyStreamSource::MyStreamSource(int fd)
        : mFd(fd),
          mFileSize(0),
          mNumPacketsSent(0) {
    mFileSize = lseek64(fd, 0, SEEK_END);
    lseek64(fd, 0, SEEK_SET);
}

MyStreamSource::~MyStreamSource() {
    close(mFd);
    mFd = -1;
}

void MyStreamSource::setListener(const sp<IStreamListener> &listener) {
    mListener = listener;
}

void MyStreamSource::setBuffers(const Vector<sp<IMemory> > &buffers) {
    mBuffers = buffers;
}

void MyStreamSource::onBufferAvailable(size_t index) {
    if(index >= mBuffers.size()){
        exit(EXIT_FAILURE);
    }
    sp < IMemory > mem = mBuffers.itemAt(index);
    ssize_t n = read(mFd, mem->pointer(), mem->size());
    if (n <= 0) {
        mListener->issueCommand(IStreamListener::EOS, false);
    } else {
        mListener->queueBuffer(index, n);
        mNumPacketsSent += n / 188;
    }
}

struct MyClient : public BnMediaPlayerClient {
    MyClient() : mEOS(false) {}

    virtual void notify(int msg, int ext1 __unused, int ext2 __unused,
                        const Parcel *obj __unused) {
        Mutex::Autolock autoLock(mLock);
        if (msg == MEDIA_ERROR || msg == MEDIA_PLAYBACK_COMPLETE) {
            mEOS = true;
            mCondition.signal();
        }
    }

    void waitForEOS() {
        Mutex::Autolock autoLock(mLock);
        while (!mEOS) {
            mCondition.wait(mLock);
        }
    }

 protected:
    virtual ~MyClient() {}

 private:
    Mutex mLock;
    Condition mCondition;
    bool mEOS;
    DISALLOW_EVIL_CONSTRUCTORS (MyClient);
};

struct DeathNotifier : public IBinder::DeathRecipient,
        public ::android::hardware::hidl_death_recipient {
    explicit DeathNotifier() {}

    virtual void binderDied(const wp<IBinder> &) {
        exit (EXIT_FAILURE);
    }

    virtual void serviceDied(
            uint64_t /* cookie */,
            const wp<::android::hidl::base::V1_0::IBase>& /* who */) {
        exit (EXIT_FAILURE);
    }
};

int main(int argc, char **argv) {
    FAIL_CHECK(argc > 1);
    android::ProcessState::self()->startThreadPool();
    sp<SurfaceComposerClient> composerClient = new SurfaceComposerClient;
    FAIL_CHECK(composerClient->initCheck() == OK);

    sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
                ISurfaceComposer::eDisplayIdMain));
    FAIL_CHECK(display != nullptr);
    DisplayInfo info;
    SurfaceComposerClient::getDisplayInfo(display, &info);
    ssize_t displayWidth = info.w;
    ssize_t displayHeight = info.h;

    sp<SurfaceControl> control = composerClient->createSurface(
            String8("A Surface"), displayWidth, displayHeight,
            PIXEL_FORMAT_RGB_565, 0);
    FAIL_CHECK(control != nullptr);
    FAIL_CHECK(control->isValid());

    SurfaceComposerClient::Transaction{}
                .setLayer(control, INT_MAX)
                .show(control)
                .apply();
    sp<Surface> surface = control->getSurface();
    FAIL_CHECK(surface != nullptr);
    sp<IServiceManager> sm = defaultServiceManager();
    FAIL_CHECK(sm != nullptr);
    sp<IBinder> binder = sm->getService(String16("media.player"));
    FAIL_CHECK(binder != nullptr);
    sp<DeathNotifier> mDeathNotifier = new DeathNotifier();
    FAIL_CHECK(mDeathNotifier != nullptr);
    binder->linkToDeath(mDeathNotifier);
    sp<IMediaPlayerService> service = interface_cast<IMediaPlayerService
            > (binder);
    FAIL_CHECK(service != nullptr);
    sp<MyClient> client = new MyClient;
    int fd = open(argv[1], O_RDONLY);
    FAIL_CHECK(fd >= 0);
    sp<IStreamSource> source = new MyStreamSource(fd);

    sp<IMediaPlayer> player = service->create(client,
                                                 AUDIO_SESSION_ALLOCATE);

    if (player != nullptr && player->setDataSource(source) == NO_ERROR) {
        player->setVideoSurfaceTexture(surface->getIGraphicBufferProducer());
        player->start();
        client->waitForEOS();
        player->stop();
    } else {
        composerClient->dispose();
        FAIL_CHECK(player != nullptr);
        FAIL_CHECK(player->setDataSource(source) != NO_ERROR);
    }

    composerClient->dispose();

    return EXIT_SUCCESS;
}
